/*
 * Nomad
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 1.1.3
 * Contact: support@hashicorp.com
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// VolumesApiService VolumesApi service
type VolumesApiService service

type ApiVolumeCsiVolumeIdActionDeleteRequest struct {
	ctx _context.Context
	ApiService *VolumesApiService
	volumeId string
	action string
	region *string
	namespace *string
	xNomadToken *string
	idempotencyToken *string
	node *string
}

func (r ApiVolumeCsiVolumeIdActionDeleteRequest) Region(region string) ApiVolumeCsiVolumeIdActionDeleteRequest {
	r.region = &region
	return r
}
func (r ApiVolumeCsiVolumeIdActionDeleteRequest) Namespace(namespace string) ApiVolumeCsiVolumeIdActionDeleteRequest {
	r.namespace = &namespace
	return r
}
func (r ApiVolumeCsiVolumeIdActionDeleteRequest) XNomadToken(xNomadToken string) ApiVolumeCsiVolumeIdActionDeleteRequest {
	r.xNomadToken = &xNomadToken
	return r
}
func (r ApiVolumeCsiVolumeIdActionDeleteRequest) IdempotencyToken(idempotencyToken string) ApiVolumeCsiVolumeIdActionDeleteRequest {
	r.idempotencyToken = &idempotencyToken
	return r
}
func (r ApiVolumeCsiVolumeIdActionDeleteRequest) Node(node string) ApiVolumeCsiVolumeIdActionDeleteRequest {
	r.node = &node
	return r
}

func (r ApiVolumeCsiVolumeIdActionDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.VolumeCsiVolumeIdActionDeleteExecute(r)
}

/*
 * VolumeCsiVolumeIdActionDelete Method for VolumeCsiVolumeIdActionDelete
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param volumeId Volume unique identifier.
 * @param action The action to perform on the Volume (create, detach, delete).
 * @return ApiVolumeCsiVolumeIdActionDeleteRequest
 */
func (a *VolumesApiService) VolumeCsiVolumeIdActionDelete(ctx _context.Context, volumeId string, action string) ApiVolumeCsiVolumeIdActionDeleteRequest {
	return ApiVolumeCsiVolumeIdActionDeleteRequest{
		ApiService: a,
		ctx: ctx,
		volumeId: volumeId,
		action: action,
	}
}

/*
 * Execute executes the request
 */
func (a *VolumesApiService) VolumeCsiVolumeIdActionDeleteExecute(r ApiVolumeCsiVolumeIdActionDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VolumesApiService.VolumeCsiVolumeIdActionDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/volume/csi/{volumeId}/{action}"
	localVarPath = strings.Replace(localVarPath, "{"+"volumeId"+"}", _neturl.PathEscape(parameterToString(r.volumeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"action"+"}", _neturl.PathEscape(parameterToString(r.action, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.namespace != nil {
		localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	if r.idempotencyToken != nil {
		localVarQueryParams.Add("idempotency_token", parameterToString(*r.idempotencyToken, ""))
	}
	if r.node != nil {
		localVarQueryParams.Add("node", parameterToString(*r.node, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNomadToken != nil {
		localVarHeaderParams["X-Nomad-Token"] = parameterToString(*r.xNomadToken, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Nomad-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Nomad-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVolumeCsiVolumeIdActionPostRequest struct {
	ctx _context.Context
	ApiService *VolumesApiService
	volumeId string
	action string
	cSIVolumeCreateRequest *CSIVolumeCreateRequest
	region *string
	namespace *string
	xNomadToken *string
	idempotencyToken *string
}

func (r ApiVolumeCsiVolumeIdActionPostRequest) CSIVolumeCreateRequest(cSIVolumeCreateRequest CSIVolumeCreateRequest) ApiVolumeCsiVolumeIdActionPostRequest {
	r.cSIVolumeCreateRequest = &cSIVolumeCreateRequest
	return r
}
func (r ApiVolumeCsiVolumeIdActionPostRequest) Region(region string) ApiVolumeCsiVolumeIdActionPostRequest {
	r.region = &region
	return r
}
func (r ApiVolumeCsiVolumeIdActionPostRequest) Namespace(namespace string) ApiVolumeCsiVolumeIdActionPostRequest {
	r.namespace = &namespace
	return r
}
func (r ApiVolumeCsiVolumeIdActionPostRequest) XNomadToken(xNomadToken string) ApiVolumeCsiVolumeIdActionPostRequest {
	r.xNomadToken = &xNomadToken
	return r
}
func (r ApiVolumeCsiVolumeIdActionPostRequest) IdempotencyToken(idempotencyToken string) ApiVolumeCsiVolumeIdActionPostRequest {
	r.idempotencyToken = &idempotencyToken
	return r
}

func (r ApiVolumeCsiVolumeIdActionPostRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.VolumeCsiVolumeIdActionPostExecute(r)
}

/*
 * VolumeCsiVolumeIdActionPost Method for VolumeCsiVolumeIdActionPost
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param volumeId Volume unique identifier.
 * @param action The action to perform on the Volume (create, detach, delete).
 * @return ApiVolumeCsiVolumeIdActionPostRequest
 */
func (a *VolumesApiService) VolumeCsiVolumeIdActionPost(ctx _context.Context, volumeId string, action string) ApiVolumeCsiVolumeIdActionPostRequest {
	return ApiVolumeCsiVolumeIdActionPostRequest{
		ApiService: a,
		ctx: ctx,
		volumeId: volumeId,
		action: action,
	}
}

/*
 * Execute executes the request
 */
func (a *VolumesApiService) VolumeCsiVolumeIdActionPostExecute(r ApiVolumeCsiVolumeIdActionPostRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VolumesApiService.VolumeCsiVolumeIdActionPost")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/volume/csi/{volumeId}/{action}"
	localVarPath = strings.Replace(localVarPath, "{"+"volumeId"+"}", _neturl.PathEscape(parameterToString(r.volumeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"action"+"}", _neturl.PathEscape(parameterToString(r.action, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.cSIVolumeCreateRequest == nil {
		return nil, reportError("cSIVolumeCreateRequest is required and must be specified")
	}

	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.namespace != nil {
		localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	if r.idempotencyToken != nil {
		localVarQueryParams.Add("idempotency_token", parameterToString(*r.idempotencyToken, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNomadToken != nil {
		localVarHeaderParams["X-Nomad-Token"] = parameterToString(*r.xNomadToken, "")
	}
	// body params
	localVarPostBody = r.cSIVolumeCreateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Nomad-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Nomad-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVolumeCsiVolumeIdDeleteRequest struct {
	ctx _context.Context
	ApiService *VolumesApiService
	volumeId string
	region *string
	namespace *string
	xNomadToken *string
	idempotencyToken *string
	force *string
}

func (r ApiVolumeCsiVolumeIdDeleteRequest) Region(region string) ApiVolumeCsiVolumeIdDeleteRequest {
	r.region = &region
	return r
}
func (r ApiVolumeCsiVolumeIdDeleteRequest) Namespace(namespace string) ApiVolumeCsiVolumeIdDeleteRequest {
	r.namespace = &namespace
	return r
}
func (r ApiVolumeCsiVolumeIdDeleteRequest) XNomadToken(xNomadToken string) ApiVolumeCsiVolumeIdDeleteRequest {
	r.xNomadToken = &xNomadToken
	return r
}
func (r ApiVolumeCsiVolumeIdDeleteRequest) IdempotencyToken(idempotencyToken string) ApiVolumeCsiVolumeIdDeleteRequest {
	r.idempotencyToken = &idempotencyToken
	return r
}
func (r ApiVolumeCsiVolumeIdDeleteRequest) Force(force string) ApiVolumeCsiVolumeIdDeleteRequest {
	r.force = &force
	return r
}

func (r ApiVolumeCsiVolumeIdDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.VolumeCsiVolumeIdDeleteExecute(r)
}

/*
 * VolumeCsiVolumeIdDelete Method for VolumeCsiVolumeIdDelete
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param volumeId Volume unique identifier.
 * @return ApiVolumeCsiVolumeIdDeleteRequest
 */
func (a *VolumesApiService) VolumeCsiVolumeIdDelete(ctx _context.Context, volumeId string) ApiVolumeCsiVolumeIdDeleteRequest {
	return ApiVolumeCsiVolumeIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		volumeId: volumeId,
	}
}

/*
 * Execute executes the request
 */
func (a *VolumesApiService) VolumeCsiVolumeIdDeleteExecute(r ApiVolumeCsiVolumeIdDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VolumesApiService.VolumeCsiVolumeIdDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/volume/csi/{volumeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"volumeId"+"}", _neturl.PathEscape(parameterToString(r.volumeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.namespace != nil {
		localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	if r.idempotencyToken != nil {
		localVarQueryParams.Add("idempotency_token", parameterToString(*r.idempotencyToken, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNomadToken != nil {
		localVarHeaderParams["X-Nomad-Token"] = parameterToString(*r.xNomadToken, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Nomad-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Nomad-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVolumeCsiVolumeIdGetRequest struct {
	ctx _context.Context
	ApiService *VolumesApiService
	volumeId string
	region *string
	namespace *string
	index *int32
	wait *int32
	stale *string
	prefix *string
	xNomadToken *string
	perPage *int32
	nextToken *string
}

func (r ApiVolumeCsiVolumeIdGetRequest) Region(region string) ApiVolumeCsiVolumeIdGetRequest {
	r.region = &region
	return r
}
func (r ApiVolumeCsiVolumeIdGetRequest) Namespace(namespace string) ApiVolumeCsiVolumeIdGetRequest {
	r.namespace = &namespace
	return r
}
func (r ApiVolumeCsiVolumeIdGetRequest) Index(index int32) ApiVolumeCsiVolumeIdGetRequest {
	r.index = &index
	return r
}
func (r ApiVolumeCsiVolumeIdGetRequest) Wait(wait int32) ApiVolumeCsiVolumeIdGetRequest {
	r.wait = &wait
	return r
}
func (r ApiVolumeCsiVolumeIdGetRequest) Stale(stale string) ApiVolumeCsiVolumeIdGetRequest {
	r.stale = &stale
	return r
}
func (r ApiVolumeCsiVolumeIdGetRequest) Prefix(prefix string) ApiVolumeCsiVolumeIdGetRequest {
	r.prefix = &prefix
	return r
}
func (r ApiVolumeCsiVolumeIdGetRequest) XNomadToken(xNomadToken string) ApiVolumeCsiVolumeIdGetRequest {
	r.xNomadToken = &xNomadToken
	return r
}
func (r ApiVolumeCsiVolumeIdGetRequest) PerPage(perPage int32) ApiVolumeCsiVolumeIdGetRequest {
	r.perPage = &perPage
	return r
}
func (r ApiVolumeCsiVolumeIdGetRequest) NextToken(nextToken string) ApiVolumeCsiVolumeIdGetRequest {
	r.nextToken = &nextToken
	return r
}

func (r ApiVolumeCsiVolumeIdGetRequest) Execute() (CSIVolume, *_nethttp.Response, error) {
	return r.ApiService.VolumeCsiVolumeIdGetExecute(r)
}

/*
 * VolumeCsiVolumeIdGet Method for VolumeCsiVolumeIdGet
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param volumeId Volume unique identifier.
 * @return ApiVolumeCsiVolumeIdGetRequest
 */
func (a *VolumesApiService) VolumeCsiVolumeIdGet(ctx _context.Context, volumeId string) ApiVolumeCsiVolumeIdGetRequest {
	return ApiVolumeCsiVolumeIdGetRequest{
		ApiService: a,
		ctx: ctx,
		volumeId: volumeId,
	}
}

/*
 * Execute executes the request
 * @return CSIVolume
 */
func (a *VolumesApiService) VolumeCsiVolumeIdGetExecute(r ApiVolumeCsiVolumeIdGetRequest) (CSIVolume, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CSIVolume
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VolumesApiService.VolumeCsiVolumeIdGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/volume/csi/{volumeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"volumeId"+"}", _neturl.PathEscape(parameterToString(r.volumeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.namespace != nil {
		localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	if r.wait != nil {
		localVarQueryParams.Add("wait", parameterToString(*r.wait, ""))
	}
	if r.stale != nil {
		localVarQueryParams.Add("stale", parameterToString(*r.stale, ""))
	}
	if r.prefix != nil {
		localVarQueryParams.Add("prefix", parameterToString(*r.prefix, ""))
	}
	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.nextToken != nil {
		localVarQueryParams.Add("next_token", parameterToString(*r.nextToken, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.index != nil {
		localVarHeaderParams["index"] = parameterToString(*r.index, "")
	}
	if r.xNomadToken != nil {
		localVarHeaderParams["X-Nomad-Token"] = parameterToString(*r.xNomadToken, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Nomad-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Nomad-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVolumeCsiVolumeIdPostRequest struct {
	ctx _context.Context
	ApiService *VolumesApiService
	volumeId string
	cSIVolumeRegisterRequest *CSIVolumeRegisterRequest
	region *string
	namespace *string
	xNomadToken *string
	idempotencyToken *string
}

func (r ApiVolumeCsiVolumeIdPostRequest) CSIVolumeRegisterRequest(cSIVolumeRegisterRequest CSIVolumeRegisterRequest) ApiVolumeCsiVolumeIdPostRequest {
	r.cSIVolumeRegisterRequest = &cSIVolumeRegisterRequest
	return r
}
func (r ApiVolumeCsiVolumeIdPostRequest) Region(region string) ApiVolumeCsiVolumeIdPostRequest {
	r.region = &region
	return r
}
func (r ApiVolumeCsiVolumeIdPostRequest) Namespace(namespace string) ApiVolumeCsiVolumeIdPostRequest {
	r.namespace = &namespace
	return r
}
func (r ApiVolumeCsiVolumeIdPostRequest) XNomadToken(xNomadToken string) ApiVolumeCsiVolumeIdPostRequest {
	r.xNomadToken = &xNomadToken
	return r
}
func (r ApiVolumeCsiVolumeIdPostRequest) IdempotencyToken(idempotencyToken string) ApiVolumeCsiVolumeIdPostRequest {
	r.idempotencyToken = &idempotencyToken
	return r
}

func (r ApiVolumeCsiVolumeIdPostRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.VolumeCsiVolumeIdPostExecute(r)
}

/*
 * VolumeCsiVolumeIdPost Method for VolumeCsiVolumeIdPost
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param volumeId Volume unique identifier.
 * @return ApiVolumeCsiVolumeIdPostRequest
 */
func (a *VolumesApiService) VolumeCsiVolumeIdPost(ctx _context.Context, volumeId string) ApiVolumeCsiVolumeIdPostRequest {
	return ApiVolumeCsiVolumeIdPostRequest{
		ApiService: a,
		ctx: ctx,
		volumeId: volumeId,
	}
}

/*
 * Execute executes the request
 */
func (a *VolumesApiService) VolumeCsiVolumeIdPostExecute(r ApiVolumeCsiVolumeIdPostRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VolumesApiService.VolumeCsiVolumeIdPost")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/volume/csi/{volumeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"volumeId"+"}", _neturl.PathEscape(parameterToString(r.volumeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.cSIVolumeRegisterRequest == nil {
		return nil, reportError("cSIVolumeRegisterRequest is required and must be specified")
	}

	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.namespace != nil {
		localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	if r.idempotencyToken != nil {
		localVarQueryParams.Add("idempotency_token", parameterToString(*r.idempotencyToken, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNomadToken != nil {
		localVarHeaderParams["X-Nomad-Token"] = parameterToString(*r.xNomadToken, "")
	}
	// body params
	localVarPostBody = r.cSIVolumeRegisterRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Nomad-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Nomad-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVolumesExternalGetRequest struct {
	ctx _context.Context
	ApiService *VolumesApiService
	region *string
	namespace *string
	index *int32
	wait *int32
	stale *string
	prefix *string
	xNomadToken *string
	perPage *int32
	nextToken *string
	pluginId *string
}

func (r ApiVolumesExternalGetRequest) Region(region string) ApiVolumesExternalGetRequest {
	r.region = &region
	return r
}
func (r ApiVolumesExternalGetRequest) Namespace(namespace string) ApiVolumesExternalGetRequest {
	r.namespace = &namespace
	return r
}
func (r ApiVolumesExternalGetRequest) Index(index int32) ApiVolumesExternalGetRequest {
	r.index = &index
	return r
}
func (r ApiVolumesExternalGetRequest) Wait(wait int32) ApiVolumesExternalGetRequest {
	r.wait = &wait
	return r
}
func (r ApiVolumesExternalGetRequest) Stale(stale string) ApiVolumesExternalGetRequest {
	r.stale = &stale
	return r
}
func (r ApiVolumesExternalGetRequest) Prefix(prefix string) ApiVolumesExternalGetRequest {
	r.prefix = &prefix
	return r
}
func (r ApiVolumesExternalGetRequest) XNomadToken(xNomadToken string) ApiVolumesExternalGetRequest {
	r.xNomadToken = &xNomadToken
	return r
}
func (r ApiVolumesExternalGetRequest) PerPage(perPage int32) ApiVolumesExternalGetRequest {
	r.perPage = &perPage
	return r
}
func (r ApiVolumesExternalGetRequest) NextToken(nextToken string) ApiVolumesExternalGetRequest {
	r.nextToken = &nextToken
	return r
}
func (r ApiVolumesExternalGetRequest) PluginId(pluginId string) ApiVolumesExternalGetRequest {
	r.pluginId = &pluginId
	return r
}

func (r ApiVolumesExternalGetRequest) Execute() (CSIVolumeListExternalResponse, *_nethttp.Response, error) {
	return r.ApiService.VolumesExternalGetExecute(r)
}

/*
 * VolumesExternalGet Method for VolumesExternalGet
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiVolumesExternalGetRequest
 */
func (a *VolumesApiService) VolumesExternalGet(ctx _context.Context) ApiVolumesExternalGetRequest {
	return ApiVolumesExternalGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return CSIVolumeListExternalResponse
 */
func (a *VolumesApiService) VolumesExternalGetExecute(r ApiVolumesExternalGetRequest) (CSIVolumeListExternalResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CSIVolumeListExternalResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VolumesApiService.VolumesExternalGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/volumes/external"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.namespace != nil {
		localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	if r.wait != nil {
		localVarQueryParams.Add("wait", parameterToString(*r.wait, ""))
	}
	if r.stale != nil {
		localVarQueryParams.Add("stale", parameterToString(*r.stale, ""))
	}
	if r.prefix != nil {
		localVarQueryParams.Add("prefix", parameterToString(*r.prefix, ""))
	}
	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.nextToken != nil {
		localVarQueryParams.Add("next_token", parameterToString(*r.nextToken, ""))
	}
	if r.pluginId != nil {
		localVarQueryParams.Add("plugin_id", parameterToString(*r.pluginId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.index != nil {
		localVarHeaderParams["index"] = parameterToString(*r.index, "")
	}
	if r.xNomadToken != nil {
		localVarHeaderParams["X-Nomad-Token"] = parameterToString(*r.xNomadToken, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Nomad-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Nomad-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVolumesGetRequest struct {
	ctx _context.Context
	ApiService *VolumesApiService
	region *string
	namespace *string
	index *int32
	wait *int32
	stale *string
	prefix *string
	xNomadToken *string
	perPage *int32
	nextToken *string
	nodeId *string
	pluginId *string
	type_ *string
}

func (r ApiVolumesGetRequest) Region(region string) ApiVolumesGetRequest {
	r.region = &region
	return r
}
func (r ApiVolumesGetRequest) Namespace(namespace string) ApiVolumesGetRequest {
	r.namespace = &namespace
	return r
}
func (r ApiVolumesGetRequest) Index(index int32) ApiVolumesGetRequest {
	r.index = &index
	return r
}
func (r ApiVolumesGetRequest) Wait(wait int32) ApiVolumesGetRequest {
	r.wait = &wait
	return r
}
func (r ApiVolumesGetRequest) Stale(stale string) ApiVolumesGetRequest {
	r.stale = &stale
	return r
}
func (r ApiVolumesGetRequest) Prefix(prefix string) ApiVolumesGetRequest {
	r.prefix = &prefix
	return r
}
func (r ApiVolumesGetRequest) XNomadToken(xNomadToken string) ApiVolumesGetRequest {
	r.xNomadToken = &xNomadToken
	return r
}
func (r ApiVolumesGetRequest) PerPage(perPage int32) ApiVolumesGetRequest {
	r.perPage = &perPage
	return r
}
func (r ApiVolumesGetRequest) NextToken(nextToken string) ApiVolumesGetRequest {
	r.nextToken = &nextToken
	return r
}
func (r ApiVolumesGetRequest) NodeId(nodeId string) ApiVolumesGetRequest {
	r.nodeId = &nodeId
	return r
}
func (r ApiVolumesGetRequest) PluginId(pluginId string) ApiVolumesGetRequest {
	r.pluginId = &pluginId
	return r
}
func (r ApiVolumesGetRequest) Type_(type_ string) ApiVolumesGetRequest {
	r.type_ = &type_
	return r
}

func (r ApiVolumesGetRequest) Execute() ([]CSIVolumeListStub, *_nethttp.Response, error) {
	return r.ApiService.VolumesGetExecute(r)
}

/*
 * VolumesGet Method for VolumesGet
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiVolumesGetRequest
 */
func (a *VolumesApiService) VolumesGet(ctx _context.Context) ApiVolumesGetRequest {
	return ApiVolumesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []CSIVolumeListStub
 */
func (a *VolumesApiService) VolumesGetExecute(r ApiVolumesGetRequest) ([]CSIVolumeListStub, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []CSIVolumeListStub
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VolumesApiService.VolumesGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/volumes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.namespace != nil {
		localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	if r.wait != nil {
		localVarQueryParams.Add("wait", parameterToString(*r.wait, ""))
	}
	if r.stale != nil {
		localVarQueryParams.Add("stale", parameterToString(*r.stale, ""))
	}
	if r.prefix != nil {
		localVarQueryParams.Add("prefix", parameterToString(*r.prefix, ""))
	}
	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.nextToken != nil {
		localVarQueryParams.Add("next_token", parameterToString(*r.nextToken, ""))
	}
	if r.nodeId != nil {
		localVarQueryParams.Add("node_id", parameterToString(*r.nodeId, ""))
	}
	if r.pluginId != nil {
		localVarQueryParams.Add("plugin_id", parameterToString(*r.pluginId, ""))
	}
	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.index != nil {
		localVarHeaderParams["index"] = parameterToString(*r.index, "")
	}
	if r.xNomadToken != nil {
		localVarHeaderParams["X-Nomad-Token"] = parameterToString(*r.xNomadToken, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Nomad-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Nomad-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVolumesPostRequest struct {
	ctx _context.Context
	ApiService *VolumesApiService
	cSIVolumeRegisterRequest *CSIVolumeRegisterRequest
	region *string
	namespace *string
	xNomadToken *string
	idempotencyToken *string
}

func (r ApiVolumesPostRequest) CSIVolumeRegisterRequest(cSIVolumeRegisterRequest CSIVolumeRegisterRequest) ApiVolumesPostRequest {
	r.cSIVolumeRegisterRequest = &cSIVolumeRegisterRequest
	return r
}
func (r ApiVolumesPostRequest) Region(region string) ApiVolumesPostRequest {
	r.region = &region
	return r
}
func (r ApiVolumesPostRequest) Namespace(namespace string) ApiVolumesPostRequest {
	r.namespace = &namespace
	return r
}
func (r ApiVolumesPostRequest) XNomadToken(xNomadToken string) ApiVolumesPostRequest {
	r.xNomadToken = &xNomadToken
	return r
}
func (r ApiVolumesPostRequest) IdempotencyToken(idempotencyToken string) ApiVolumesPostRequest {
	r.idempotencyToken = &idempotencyToken
	return r
}

func (r ApiVolumesPostRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.VolumesPostExecute(r)
}

/*
 * VolumesPost Method for VolumesPost
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiVolumesPostRequest
 */
func (a *VolumesApiService) VolumesPost(ctx _context.Context) ApiVolumesPostRequest {
	return ApiVolumesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *VolumesApiService) VolumesPostExecute(r ApiVolumesPostRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VolumesApiService.VolumesPost")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/volumes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.cSIVolumeRegisterRequest == nil {
		return nil, reportError("cSIVolumeRegisterRequest is required and must be specified")
	}

	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.namespace != nil {
		localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	if r.idempotencyToken != nil {
		localVarQueryParams.Add("idempotency_token", parameterToString(*r.idempotencyToken, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNomadToken != nil {
		localVarHeaderParams["X-Nomad-Token"] = parameterToString(*r.xNomadToken, "")
	}
	// body params
	localVarPostBody = r.cSIVolumeRegisterRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Nomad-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Nomad-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVolumesSnapshotDeleteRequest struct {
	ctx _context.Context
	ApiService *VolumesApiService
	region *string
	namespace *string
	xNomadToken *string
	idempotencyToken *string
	pluginId *string
	snapshotId *string
}

func (r ApiVolumesSnapshotDeleteRequest) Region(region string) ApiVolumesSnapshotDeleteRequest {
	r.region = &region
	return r
}
func (r ApiVolumesSnapshotDeleteRequest) Namespace(namespace string) ApiVolumesSnapshotDeleteRequest {
	r.namespace = &namespace
	return r
}
func (r ApiVolumesSnapshotDeleteRequest) XNomadToken(xNomadToken string) ApiVolumesSnapshotDeleteRequest {
	r.xNomadToken = &xNomadToken
	return r
}
func (r ApiVolumesSnapshotDeleteRequest) IdempotencyToken(idempotencyToken string) ApiVolumesSnapshotDeleteRequest {
	r.idempotencyToken = &idempotencyToken
	return r
}
func (r ApiVolumesSnapshotDeleteRequest) PluginId(pluginId string) ApiVolumesSnapshotDeleteRequest {
	r.pluginId = &pluginId
	return r
}
func (r ApiVolumesSnapshotDeleteRequest) SnapshotId(snapshotId string) ApiVolumesSnapshotDeleteRequest {
	r.snapshotId = &snapshotId
	return r
}

func (r ApiVolumesSnapshotDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.VolumesSnapshotDeleteExecute(r)
}

/*
 * VolumesSnapshotDelete Method for VolumesSnapshotDelete
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiVolumesSnapshotDeleteRequest
 */
func (a *VolumesApiService) VolumesSnapshotDelete(ctx _context.Context) ApiVolumesSnapshotDeleteRequest {
	return ApiVolumesSnapshotDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *VolumesApiService) VolumesSnapshotDeleteExecute(r ApiVolumesSnapshotDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VolumesApiService.VolumesSnapshotDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/volumes/snapshot"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.namespace != nil {
		localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	if r.idempotencyToken != nil {
		localVarQueryParams.Add("idempotency_token", parameterToString(*r.idempotencyToken, ""))
	}
	if r.pluginId != nil {
		localVarQueryParams.Add("plugin_id", parameterToString(*r.pluginId, ""))
	}
	if r.snapshotId != nil {
		localVarQueryParams.Add("snapshot_id", parameterToString(*r.snapshotId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNomadToken != nil {
		localVarHeaderParams["X-Nomad-Token"] = parameterToString(*r.xNomadToken, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Nomad-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Nomad-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVolumesSnapshotGetRequest struct {
	ctx _context.Context
	ApiService *VolumesApiService
	region *string
	namespace *string
	index *int32
	wait *int32
	stale *string
	prefix *string
	xNomadToken *string
	perPage *int32
	nextToken *string
	pluginId *string
}

func (r ApiVolumesSnapshotGetRequest) Region(region string) ApiVolumesSnapshotGetRequest {
	r.region = &region
	return r
}
func (r ApiVolumesSnapshotGetRequest) Namespace(namespace string) ApiVolumesSnapshotGetRequest {
	r.namespace = &namespace
	return r
}
func (r ApiVolumesSnapshotGetRequest) Index(index int32) ApiVolumesSnapshotGetRequest {
	r.index = &index
	return r
}
func (r ApiVolumesSnapshotGetRequest) Wait(wait int32) ApiVolumesSnapshotGetRequest {
	r.wait = &wait
	return r
}
func (r ApiVolumesSnapshotGetRequest) Stale(stale string) ApiVolumesSnapshotGetRequest {
	r.stale = &stale
	return r
}
func (r ApiVolumesSnapshotGetRequest) Prefix(prefix string) ApiVolumesSnapshotGetRequest {
	r.prefix = &prefix
	return r
}
func (r ApiVolumesSnapshotGetRequest) XNomadToken(xNomadToken string) ApiVolumesSnapshotGetRequest {
	r.xNomadToken = &xNomadToken
	return r
}
func (r ApiVolumesSnapshotGetRequest) PerPage(perPage int32) ApiVolumesSnapshotGetRequest {
	r.perPage = &perPage
	return r
}
func (r ApiVolumesSnapshotGetRequest) NextToken(nextToken string) ApiVolumesSnapshotGetRequest {
	r.nextToken = &nextToken
	return r
}
func (r ApiVolumesSnapshotGetRequest) PluginId(pluginId string) ApiVolumesSnapshotGetRequest {
	r.pluginId = &pluginId
	return r
}

func (r ApiVolumesSnapshotGetRequest) Execute() (CSISnapshotListResponse, *_nethttp.Response, error) {
	return r.ApiService.VolumesSnapshotGetExecute(r)
}

/*
 * VolumesSnapshotGet Method for VolumesSnapshotGet
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiVolumesSnapshotGetRequest
 */
func (a *VolumesApiService) VolumesSnapshotGet(ctx _context.Context) ApiVolumesSnapshotGetRequest {
	return ApiVolumesSnapshotGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return CSISnapshotListResponse
 */
func (a *VolumesApiService) VolumesSnapshotGetExecute(r ApiVolumesSnapshotGetRequest) (CSISnapshotListResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CSISnapshotListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VolumesApiService.VolumesSnapshotGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/volumes/snapshot"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.namespace != nil {
		localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	if r.wait != nil {
		localVarQueryParams.Add("wait", parameterToString(*r.wait, ""))
	}
	if r.stale != nil {
		localVarQueryParams.Add("stale", parameterToString(*r.stale, ""))
	}
	if r.prefix != nil {
		localVarQueryParams.Add("prefix", parameterToString(*r.prefix, ""))
	}
	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.nextToken != nil {
		localVarQueryParams.Add("next_token", parameterToString(*r.nextToken, ""))
	}
	if r.pluginId != nil {
		localVarQueryParams.Add("plugin_id", parameterToString(*r.pluginId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.index != nil {
		localVarHeaderParams["index"] = parameterToString(*r.index, "")
	}
	if r.xNomadToken != nil {
		localVarHeaderParams["X-Nomad-Token"] = parameterToString(*r.xNomadToken, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Nomad-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Nomad-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVolumesSnapshotPostRequest struct {
	ctx _context.Context
	ApiService *VolumesApiService
	cSISnapshotCreateRequest *CSISnapshotCreateRequest
	region *string
	namespace *string
	xNomadToken *string
	idempotencyToken *string
}

func (r ApiVolumesSnapshotPostRequest) CSISnapshotCreateRequest(cSISnapshotCreateRequest CSISnapshotCreateRequest) ApiVolumesSnapshotPostRequest {
	r.cSISnapshotCreateRequest = &cSISnapshotCreateRequest
	return r
}
func (r ApiVolumesSnapshotPostRequest) Region(region string) ApiVolumesSnapshotPostRequest {
	r.region = &region
	return r
}
func (r ApiVolumesSnapshotPostRequest) Namespace(namespace string) ApiVolumesSnapshotPostRequest {
	r.namespace = &namespace
	return r
}
func (r ApiVolumesSnapshotPostRequest) XNomadToken(xNomadToken string) ApiVolumesSnapshotPostRequest {
	r.xNomadToken = &xNomadToken
	return r
}
func (r ApiVolumesSnapshotPostRequest) IdempotencyToken(idempotencyToken string) ApiVolumesSnapshotPostRequest {
	r.idempotencyToken = &idempotencyToken
	return r
}

func (r ApiVolumesSnapshotPostRequest) Execute() (CSISnapshotCreateResponse, *_nethttp.Response, error) {
	return r.ApiService.VolumesSnapshotPostExecute(r)
}

/*
 * VolumesSnapshotPost Method for VolumesSnapshotPost
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiVolumesSnapshotPostRequest
 */
func (a *VolumesApiService) VolumesSnapshotPost(ctx _context.Context) ApiVolumesSnapshotPostRequest {
	return ApiVolumesSnapshotPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return CSISnapshotCreateResponse
 */
func (a *VolumesApiService) VolumesSnapshotPostExecute(r ApiVolumesSnapshotPostRequest) (CSISnapshotCreateResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CSISnapshotCreateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VolumesApiService.VolumesSnapshotPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/volumes/snapshot"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.cSISnapshotCreateRequest == nil {
		return localVarReturnValue, nil, reportError("cSISnapshotCreateRequest is required and must be specified")
	}

	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.namespace != nil {
		localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	if r.idempotencyToken != nil {
		localVarQueryParams.Add("idempotency_token", parameterToString(*r.idempotencyToken, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNomadToken != nil {
		localVarHeaderParams["X-Nomad-Token"] = parameterToString(*r.xNomadToken, "")
	}
	// body params
	localVarPostBody = r.cSISnapshotCreateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Nomad-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Nomad-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
